library(rattle)
rattle()
library(lattice)
?lattice
data(environmental)
head(environmental)
> library(lattice)
> ?lattice
> data(environmental)
> head(environmental)
library(lattice)
?lattice
data(environmental)
head(environmental)
xyplot(ozone=radiation, data=environmental)
xyplot(ozone$radiation, data=environmental)
?tilde
xyplot(ozone~radiation, data=environmental)
xyplot(ozone~radiation, data=environmental, main = "Ozone vs. Radiation")
library(lattice)
xyplot(ozone~temperature, data=environmental)
summary(environmental$temperature)
temp.cut <- equal.count(environmental$temlperature, 4)
temp.cut <- equal.count(environmental$temperature, 4)
temp.cut
?tilde
?,
?:
?::
??:
?slash
?point
xyplot(ozone~radiation temp.cut, data=environmental)
xyplot(ozone~radiation | temp.cut, data=environmental)
syplot(ozone~wind | temp.cut, data=environmental)
syplot(ozone~wind | temp.cut, data=environmental)
xyplot(ozone~wind | temp.cut, data=environmental)
rm(acs)
library(streamR)
filterStream
load("/Users/cyrillepapon/Desktop/Fichier de travail R/streamR/streamR-mongo/data/example_tweets.rdata")
load("/Users/cyrillepapon/Desktop/Fichier de travail R/programmes/MongoDB/DF8.RData")
View(DF8)
library()
mem_used()
rm(acs)
load("~/Desktop/Fichier de travail R/programmes/MongoDB/WorkSpace/test.RData")
install.packages(c("abc", "abctools", "accelerometry", "accrued", "AdaptFitOS", "afex", "agricolae", "agridat", "AICcmodavg", "AMOEBA", "anacor", "animation", "antitrust", "AntWeb", "apcluster", "ape", "AppliedPredictiveModeling", "aprof", "apt", "arfima", "arm", "arules", "arulesNBMiner", "asbio", "astro", "BAMMtools", "bartMachine", "base64enc", "BatchExperiments", "BatchJobs", "BayesBridge", "bayescount", "BayesFactor", "Bayesianbetareg", "BayesLogit", "bayesPop", "bayesSurv", "BayesX", "BCA", "BDgraph", "bdsmatrix", "Bergm", "bezier", "bfast", "BH", "bigmemory.sri", "bigRR", "bigsplines", "bingat", "binseqtest", "BioMark", "biomod2", "bionetdata", "BioStatR", "blkergm", "BMA", "boilerpipeR", "bold", "BoolNet", "bpkde", "BrailleR", "BSSasymp", "bst", "BTYD", "bujar", "ca", "cAIC4", "CAMAN", "car", "care", "caret", "caTools", "catR", "CAvariants", "CBPS", "CCTpack", "CDM", "cg", "cgam", "cgAUC", "ChainLadder", "changepoint", "CHAT", "chebpol", "checkmate", "cheddar", "ChemometricsWithR", "chemosensors", "cherry", "chipPCR", "chords", "CircE", "circlize", "class", "classify", "clickstream", "clinfun", "cluster", "clusterSim", "ClustVarLV", "CoClust", "codep", "codetools", "colourlovers", "commandr", "CommonJavaJars", "compareGroups", "CompRandFld", "cond", "CondReg", "copula", "CopulaRegression", "corHMM", "CORM", "CorReg", "corrgram", "COSINE", "COUNT", "countrycode", "CovSel", "Cprob", "cramer", "CRF", "crrstep", "crs", "ctv", "cvxclustr", "d3Network", "DatABEL", "DataCombine", "dave", "DBI", "decctools", "Delaporte", "deldir", "deltaPlotR", "dendextend", "dendroextras", "descr", "deSolve", "DFIT", "dglars", "dgmb", "dicionariosIBGE", "DiscML", "discreteRV", "diseasemapping", "dismo", "distr", "dlnm", "DNAprofiles", "dnet", "doBy", "DoE.base", "domino", "dpcR", "drfit", "ds", "DTR", "dynBiplotGUI", "dynsim", "e1071", "easyanova", "Ecdat", "ecoengine", "effects", "effsize", "eggCounts", "eive", "ELT", "EMMIXuskew", "EMP", "emplik", "emulator", "enviPat", "Epi", "EpiDynamics", "EpiModel", "epiR", "erer", "ergm", "evmix", "EvoRAG", "exact2x2", "exactmeta", "ExceedanceTools", "ExomeDepth", "expp", "ExtDist", "extraTrees", "extRemes", "ezsim", "FactoMineR", "Familias", "fanplot", "fastGHQuad", "fastR", "fcros", "FD", "fdakma", "federalregister", "FeedbackTS", "fICA", "FisHiCal", "flare", "flora", "fmsb", "fMultivar", "forecast", "formatR", "Formula", "fpc", "freqweights", "FrF2", "fscaret", "ftsa", "functional", "fwi.fbp", "gamboostLSS", "gamclass", "gamm4", "gap", "GDAtools", "gdimap", "geigen", "GenBinomApps", "GeneNet", "GeneticTools", "geomorph", "georob", "geosphere", "geostatsp", "GetoptLong", "gettingtothebottom", "GGally", "GGIR", "gglasso", "GGMselect", "GISTools", "glarma", "glasso", "glcm", "glmmLasso", "globalOptTests", "GLSME", "gMCP", "GMD", "Gmisc", "gmp", "gMWT", "GoFKernel", "googleVis", "GPfit", "gplots", "GPvam", "gramEvol", "GrapheR", "groc", "growthrate", "grplasso", "grpreg", "gsDesign", "gss", "gsubfn", "gWidgets", "gWidgetstcltk", "GxM", "HAC", "hapassoc", "haplo.stats", "HardyWeinberg", "hasseDiagram", "hdi", "heavy", "helloJavaWorld", "heplots", "hexbin", "hglasso", "hglm", "HiClimR", "HiddenMarkov", "HistogramTools", "hitandrun", "hmm.discnp", "hmmm", "HSAUR", "HSAUR2", "HSAUR3", "hSDM", "hsphase", "htmltools", "hts", "HTSCluster", "HTSDiff", "httr", "hwriter", "hypervolume", "IAT", "IBDhaploRtools", "ic.infer", "icensmis", "idr", "ifultools", "imguR", "indicspecies", "ineq", "influence.SEM", "infotheo", "INLABMA", "InterVA4", "investr", "irace", "isotone", "jaatha", "jsonlite", "jvmr", "KANT", "kedd", "kinship2", "klaR", "kmi", "knitcitations", "kohonen", "labeling", "laeken", "laGP", "LatticeKrig", "ldr", "leafletR", "LEAPFrOG", "lfstat", "lgarch", "lgtdl", "libamtrack", "likelihood", "likeLTD", "LinearizedSVR", "linkcomm", "list", "lme4", "lmerTest", "lmSupport", "LogConcDEAD", "logcondens", "LPmerge", "lpSolve", "lpSolveAPI", "LPStimeSeries", "LSAfun", "lsmeans", "mada", "magicaxis", "MALDIquant", "MALDIquantForeign", "ManyTests", "MAPA", "markdown", "MASS", "matlab", "MBmca", "mboost", "MCDA", "mcIRT", "mded", "MDPtoolbox", "mediation", "mem", "meta", "metafor", "mewAvg", "mgcv", "mht", "miceadds", "MicroDatosEs", "MicSim", "migest", "mime", "minerva", "minque", "mirt", "miRtest", "miscFuncs", "miscset", "mixlm", "mixOmics", "mixture", "mkin", "mlr", "mmcm", "mme", "mmod", "mnlogit", "mnormt", "MODISTools", "mokken", "MonetDB.R", "mosaic", "movMF", "MPTinR", "MPV", "mRMRe", "msarc", "MSBVAR", "msm", "msme", "MTurkR", "muhaz", "multcomp", "multigroup", "MultiLCIRT", "MuMIn", "muscle", "mutossGUI", "mvabund", "mvcwt", "mvmeta", "mvoutlier", "mvpart", "mvSLOUCH", "mvtnorm", "mwa", "MXM", "nanop", "NAPPA", "NbClust", "ncdf", "NCmisc", "ncvreg", "NeatMap", "netmeta", "network", "ngramr", "ngspatial", "nleqslv", "nloptr", "NLP", "nlstools", "nontarget", "nopp", "nor1mix", "np", "npcp", "npmlreg", "NScluster", "nsprcomp", "nsRFA", "numOSL", "OceanView", "Ohmage", "OpasnetUtils", "opencpu", "OpenRepGrid", "openxlsx", "operators", "optmatch", "optR", "ORCME", "OrdFacReg", "osDesign", "OutbreakTools", "OUwie", "paleobioDB", "paleotree", "pamr", "parallelMap", "ParamHelpers", "parcor", "party", "partykit", "pbdNCDF4", "pbkrtest", "pcalg", "pcnetmeta", "PCovR", "pdfetch", "pec", "pedgene", "pedigreemm", "pegas", "peptider", "Peptides", "PerfMeas", "phaseR", "pheno2geno", "phenology", "phonTools", "phtt", "phyloland", "phytools", "pipeR", "pitchRx", "PivotalR", "PKfit", "planar", "planor", "plotSEMM", "plsdof", "plsRcox", "plsRglm", "pmg", "pocrm", "pollstR", "pomp", "PopGenome", "PopGenReport", "poppr", "portes", "PottsUtils", "Power2Stage", "powerGWASinteraction", "PowerTOST", "PP", "ppls", "pqantimalarials", "pracma", "PracTools", "PReMiuM", "PResiduals", "prodlim", "ProgGUIinR", "protr", "protViz", "PSAboot", "pscl", "psych", "psychomix", "psychotools", "psychotree", "PTAk", "ptinpoly", "PtProcess", "PubMedWordcloud", "pvsR", "pyramid", "qcc", "qdap", "qdapDictionaries", "qdapTools", "qmethod", "qpcR", "qtl", "QuantifQuantile", "quantregGrowth", "questionr", "R.devices", "R.filesets", "R.utils", "R2HTML", "R4CouchDB", "r4ss", "rags2ridges", "raincpc", "random.polychor.pa", "RandomFields", "randomForest", "randomForestSRC", "randomLCA", "randtoolbox", "RankAggreg", "Rankcluster", "RANN", "rARPACK", "raster", "rasterVis", "rattle", "rAvis", "Rbitcoin", "Rcapture", "rcdk", "rcdklibs", "RCEIM", "rChoiceDialogs", "rClinicalCodes", "Rcmdr", "RcmdrPlugin.BCA", "RcmdrPlugin.DoE", "RcmdrPlugin.EBM", "RcmdrPlugin.EZR", "RcmdrPlugin.IPSUR", "RcmdrPlugin.NMBU", "RcmdrPlugin.temis", "RcppArmadillo", "RcppEigen", "RCurl", "Rd2roxygen", "readbitmap", "reader", "rebmix", "recommenderlab", "referenceIntervals", "RefFreeEWAS", "RefManageR", "refund", "regress", "reldist", "ReporteRs", "ReporteRsjars", "REPPlab", "rfigshare", "Rfit", "RFLPtools", "rforensicbatwing", "rfPermute", "rgbif", "RGENERATE", "rgeos", "rgl", "rgp", "RGtk2", "RHive", "RImpala", "rinat", "rioja", "rite", "RItools", "riverplot", "RJDBC", "rje", "RJSONIO", "Rlabkey", "rLakeAnalyzer", "RLRsim", "rmgarch", "Rmpfr", "RNetCDF", "rngWELL", "rnoaa", "robCompositions", "RobPer", "robumeta", "robustlmm", "rockchalk", "rococo", "rorutadis", "ROSE", "roxygen2", "rpf", "rplos", "RPPanalyzer", "rprintf", "rPython", "RSA", "RSiteCatalyst", "Rsomoclu", "Rtsne", "Rttf2pt1", "Runuran", "RVAideMemoire", "RWebLogo", "rwt", "rysgran", "sampleSelection", "sandwich", "sanon", "SAPP", "SASxport", "SCGLR", "scholar", "schoRsch", "scoring", "SCRT", "SCVA", "sda", "SDaA", "sdcMicro", "sde", "SDMTools", "sdmvspecies", "season", "segmented", "selectMeta", "sem", "SemiParBIVProbit", "SemiParSampleSel", "semPlot", "sensitivity", "sensitivitymw", "sgr", "shiny", "shotGroups", "ShrinkCovMat", "Sim.DiffProc", "simPH", "sirt", "SIS", "sitar", "sjPlot", "smacof", "SMNCensReg", "sms", "sn", "SNFtool", "SnowballC", "SNSequate", "SocialNetworks", "soilphysics", "SPACECAP", "spacetime", "spam", "spaMM", "sparkTable", "SparseM", "spartan", "spatial.tools", "spatialTailDep", "SpatialTools", "spatstat", "spatsurv", "spcadjust", "spd", "spfrontier", "splusTimeDate", "spMC", "spocc", "spTimer", "spuRs", "SQUAREM", "squash", "SSDforR", "ssym", "StAMPP", "statfi", "StereoMorph", "stm", "stocc", "stochvol", "stosim", "strap", "stream", "stringdist", "structSSI", "strum", "strvalidator", "stsm.class", "stylo", "subplex", "sudoku", "SuperLearner", "support.BWS", "support.CEs", "Surrogate", "surv2sampleComp", "survey", "survivalMPL", "survsim", "sweSCB", "swirl", "sybilcycleFreeFlux", "symmoments", "synbreed", "synchrony", "tab", "tables", "TableToLongForm", "TAM", "taxize", "tbart", "TDMR", "teigen", "TEQR", "TestScorer", "texreg", "Thinknum", "tiger", "tigerstats", "timsac", "tm.plugin.factiva", "TopKLists", "topologyGSA", "traitr", "translate", "transport", "TreePar", "TreeSim", "TreeSimGM", "TripleR", "TSdist", "tsDyn", "TSP", "tth", "ttScreening", "TukeyC", "turboEM", "TurtleGraphics", "twostageTE", "upclass", "UScancer", "UsingR", "vardpoor", "vcd", "Vdgraph", "VennDiagram", "verification", "VideoComparison", "visreg", "vows", "vrtest", "wbs", "weatherData", "wfe", "wgaim", "WhopGenome", "WikipediR", "wordnet", "wpp2012", "wppExplorer", "wskm", "XBRL", "xergm", "XLConnect", "xlsx", "xlsxjars", "yaImpute", "yhatr", "YuGene", "yuima", "zCompositions"))
install.packages("abc")
install.packages("abctools")
install.packages("accelerometry")
install.packages(c("accrued", "AdaptFitOS", "afex", "agricolae", "agridat", "AICcmodavg", "AMOEBA", "anacor", "animation", "antitrust", "AntWeb", "apcluster", "ape", "AppliedPredictiveModeling", "aprof"))
install.packages(c("apt", "arfima", "arm", "arules", "arulesNBMiner", "asbio", "astro", "BAMMtools", "bartMachine", "base64enc", "BatchExperiments", "BatchJobs", "BayesBridge", "bayescount", "BayesFactor", "Bayesianbetareg", "BayesLogit", "bayesPop", "bayesSurv", "BayesX", "BCA", "BDgraph", "bdsmatrix", "Bergm", "bezier", "bfast", "BH", "bigmemory.sri", "bigRR", "bigsplines"))
install.packages(c("bingat", "binseqtest", "BioMark", "biomod2", "bionetdata", "BioStatR", "blkergm", "BMA", "boilerpipeR", "bold", "BoolNet", "bpkde", "BrailleR", "BSSasymp", "bst", "BTYD", "bujar", "ca", "cAIC4", "CAMAN", "care", "caret", "caTools", "catR", "CAvariants", "CBPS", "CCTpack", "CDM", "cg", "cgam", "cgAUC", "ChainLadder", "changepoint", "CHAT", "chebpol", "cheddar", "ChemometricsWithR", "chemosensors", "cherry", "chipPCR", "chords", "CircE", "circlize", "class", "classify", "clickstream", "clinfun", "cluster", "clusterSim", "ClustVarLV", "CoClust"))
install.packages(c("codep", "codetools", "colourlovers", "commandr", "CommonJavaJars", "compareGroups", "CompRandFld", "cond", "CondReg", "copula", "CopulaRegression", "corHMM", "CORM", "CorReg", "corrgram", "COSINE", "COUNT", "countrycode", "CovSel", "Cprob", "cramer", "CRF", "crrstep", "crs", "ctv", "cvxclustr", "d3Network", "DatABEL", "DataCombine", "dave", "DBI", "decctools", "Delaporte", "deldir", "deltaPlotR", "dendextend", "dendroextras", "descr", "deSolve", "DFIT", "dglars", "dgmb", "dicionariosIBGE", "DiscML", "discreteRV", "diseasemapping", "dismo", "distr", "dlnm", "DNAprofiles", "dnet", "doBy", "DoE.base", "domino", "dpcR", "drfit", "ds", "DTR", "dynBiplotGUI", "dynsim"))
install.packages(c("e1071", "easyanova", "Ecdat", "ecoengine", "effects", "effsize", "eggCounts", "eive", "ELT", "EMMIXuskew", "EMP", "emplik", "emulator", "enviPat", "Epi", "EpiDynamics", "EpiModel"))
install.packages(c("epiR", "erer", "ergm", "evmix", "EvoRAG", "exact2x2", "exactmeta", "ExceedanceTools", "ExomeDepth", "expp", "ExtDist", "extraTrees", "extRemes", "ezsim", "FactoMineR", "Familias", "fanplot", "fastGHQuad", "fastR", "fcros", "FD", "fdakma", "federalregister", "FeedbackTS", "fICA", "FisHiCal", "flare", "flora", "fmsb", "fMultivar", "forecast", "formatR", "Formula", "fpc", "freqweights", "FrF2", "fscaret", "ftsa", "functional", "fwi.fbp", "gamboostLSS", "gamclass", "gamm4", "gap", "GDAtools", "gdimap", "geigen", "GenBinomApps", "GeneNet"))
install.packages(c("GeneticTools", "geomorph", "georob", "geosphere", "geostatsp", "GetoptLong", "gettingtothebottom", "GGally", "GGIR", "gglasso", "GGMselect", "GISTools", "glarma", "glasso", "glcm", "glmmLasso", "globalOptTests", "GLSME", "gMCP", "GMD", "Gmisc", "gmp", "gMWT", "GoFKernel"))
install.packages(c("googleVis", "GPfit", "gplots", "GPvam", "gramEvol", "GrapheR", "groc", "growthrate", "grplasso", "grpreg", "gsDesign", "gss", "gsubfn", "gWidgets", "gWidgetstcltk", "GxM", "HAC", "hapassoc", "haplo.stats", "HardyWeinberg", "hasseDiagram", "hdi", "heavy", "helloJavaWorld", "heplots", "hexbin", "hglasso", "hglm", "HiClimR", "HiddenMarkov", "HistogramTools"))
install.packages(c("hitandrun", "hmm.discnp", "hmmm", "HSAUR", "HSAUR2", "HSAUR3", "hSDM", "hsphase", "htmltools", "hts", "HTSCluster", "HTSDiff", "httr", "hwriter", "hypervolume", "IAT", "IBDhaploRtools", "ic.infer", "icensmis", "idr", "ifultools", "imguR", "indicspecies", "ineq", "influence.SEM", "infotheo", "INLABMA", "InterVA4", "investr", "irace", "isotone", "jaatha", "jsonlite", "jvmr", "KANT", "kedd", "kinship2", "klaR", "kmi", "knitcitations", "kohonen", "labeling", "laeken", "laGP", "LatticeKrig", "ldr", "leafletR", "LEAPFrOG", "lfstat", "lgarch", "lgtdl", "libamtrack", "likelihood", "likeLTD", "LinearizedSVR", "linkcomm", "list", "lme4", "lmerTest", "lmSupport", "LogConcDEAD"))
install.packages(c("logcondens", "LPmerge", "lpSolve", "lpSolveAPI", "LPStimeSeries", "LSAfun", "lsmeans", "mada", "magicaxis", "MALDIquant", "MALDIquantForeign", "ManyTests", "MAPA", "markdown", "MASS", "matlab", "MBmca", "MCDA", "mcIRT", "mded", "MDPtoolbox", "mediation", "mem", "meta", "metafor", "mewAvg", "mgcv", "mht", "miceadds", "MicroDatosEs", "MicSim", "migest", "mime", "minerva", "minque", "mirt", "miRtest", "miscFuncs", "miscset", "mixlm", "mixOmics", "mixture", "mkin", "mlr", "mmcm", "mme", "mmod", "mnlogit", "mnormt", "MODISTools", "mokken", "MonetDB.R", "mosaic", "movMF", "MPTinR", "MPV", "mRMRe", "msarc", "MSBVAR", "msm"))
install.packages(c("msme", "MTurkR", "muhaz", "multcomp", "multigroup", "MultiLCIRT", "MuMIn", "muscle", "mutossGUI", "mvabund", "mvcwt", "mvmeta", "mvoutlier", "mvpart", "mvSLOUCH", "mvtnorm", "mwa", "MXM", "nanop", "NAPPA", "NbClust", "ncdf", "NCmisc", "ncvreg", "NeatMap", "netmeta", "network", "ngramr", "ngspatial", "nleqslv", "nloptr", "NLP", "nlstools", "nontarget", "nopp", "nor1mix", "np", "npcp", "npmlreg", "NScluster", "nsprcomp", "nsRFA", "numOSL", "OceanView", "Ohmage", "OpasnetUtils", "opencpu", "OpenRepGrid", "openxlsx", "operators", "optmatch", "optR", "ORCME", "OrdFacReg", "osDesign", "OutbreakTools", "OUwie", "paleobioDB", "paleotree", "pamr", "parcor", "party", "partykit", "pbdNCDF4", "pbkrtest", "pcalg", "pcnetmeta", "PCovR", "pdfetch", "pec", "pedgene", "pedigreemm", "pegas", "peptider", "Peptides", "PerfMeas"))
install.packages(c("phaseR", "pheno2geno", "phenology", "phonTools", "phtt", "phyloland", "phytools", "pipeR", "pitchRx", "PivotalR", "PKfit", "planar", "planor", "plotSEMM", "plsdof", "plsRcox", "plsRglm", "pmg", "pocrm", "pollstR", "pomp", "PopGenome", "PopGenReport", "poppr", "portes", "PottsUtils", "Power2Stage", "powerGWASinteraction", "PowerTOST", "PP", "ppls", "pqantimalarials", "pracma", "PracTools", "PReMiuM", "PResiduals", "prodlim", "ProgGUIinR", "protr", "protViz", "PSAboot", "pscl", "psych", "psychomix", "psychotools", "psychotree", "PTAk", "ptinpoly", "PtProcess", "PubMedWordcloud", "pvsR", "pyramid", "qcc", "qdap", "qdapDictionaries", "qdapTools", "qmethod"))
install.packages(c("qpcR", "qtl", "QuantifQuantile", "quantregGrowth", "questionr", "R.devices", "R.filesets", "R.utils", "R2HTML", "R4CouchDB", "r4ss", "rags2ridges", "raincpc", "random.polychor.pa", "RandomFields", "randomForest", "randomForestSRC", "randomLCA", "randtoolbox", "RankAggreg", "Rankcluster", "RANN", "rARPACK", "raster", "rasterVis", "rattle", "rAvis", "Rbitcoin", "Rcapture", "rcdk", "rcdklibs", "RCEIM", "rChoiceDialogs", "rClinicalCodes", "RcmdrPlugin.BCA", "RcmdrPlugin.DoE", "RcmdrPlugin.EBM", "RcmdrPlugin.EZR", "RcmdrPlugin.IPSUR", "RcmdrPlugin.NMBU", "RcmdrPlugin.temis", "RcppArmadillo", "RcppEigen", "RCurl", "Rd2roxygen", "readbitmap", "reader", "rebmix", "recommenderlab", "referenceIntervals", "RefFreeEWAS", "RefManageR", "refund", "regress", "reldist", "ReporteRs", "ReporteRsjars", "REPPlab", "rfigshare", "Rfit", "RFLPtools", "rforensicbatwing", "rfPermute", "rgbif", "RGENERATE", "rgeos", "rgl", "rgp", "RGtk2", "RHive", "RImpala", "rinat", "rioja", "rite", "RItools", "riverplot", "RJDBC", "rje", "RJSONIO", "Rlabkey", "rLakeAnalyzer", "RLRsim", "rmgarch", "Rmpfr", "RNetCDF", "rngWELL", "rnoaa", "robCompositions", "RobPer", "robumeta", "robustlmm", "rockchalk", "rococo", "rorutadis", "ROSE", "roxygen2", "rpf", "rplos", "RPPanalyzer", "rprintf", "rPython", "RSA", "RSiteCatalyst", "Rsomoclu", "Rtsne", "Rttf2pt1", "Runuran", "RVAideMemoire", "RWebLogo", "rwt", "rysgran", "sampleSelection", "sandwich", "sanon", "SAPP", "SASxport", "SCGLR", "scholar", "schoRsch", "scoring", "SCRT", "SCVA", "sda", "SDaA", "sdcMicro", "sde", "SDMTools", "sdmvspecies", "season", "segmented", "selectMeta", "sem", "SemiParBIVProbit", "SemiParSampleSel", "semPlot", "sensitivity", "sensitivitymw", "sgr", "shiny", "shotGroups", "ShrinkCovMat", "Sim.DiffProc", "simPH", "sirt", "SIS", "sitar", "sjPlot", "smacof", "SMNCensReg", "sms", "sn", "SNFtool", "SnowballC", "SNSequate", "SocialNetworks", "soilphysics", "SPACECAP", "spacetime", "spam", "spaMM", "sparkTable", "SparseM", "spartan", "spatial.tools", "spatialTailDep", "SpatialTools", "spatstat", "spatsurv", "spcadjust", "spd", "spfrontier", "splusTimeDate", "spMC", "spocc", "spTimer", "spuRs", "SQUAREM", "squash", "SSDforR", "ssym", "StAMPP", "statfi", "StereoMorph", "stm", "stocc", "stochvol", "stosim", "strap", "stream", "stringdist", "structSSI", "strum", "strvalidator", "stsm.class", "stylo", "subplex", "sudoku", "SuperLearner", "support.BWS", "support.CEs", "Surrogate", "surv2sampleComp", "survey", "survivalMPL", "survsim", "sweSCB", "swirl", "sybilcycleFreeFlux", "symmoments", "synbreed", "synchrony", "tab", "tables", "TableToLongForm", "TAM", "taxize", "tbart", "TDMR", "teigen", "TEQR", "TestScorer", "texreg", "Thinknum", "tiger", "tigerstats", "timsac", "tm.plugin.factiva", "TopKLists", "topologyGSA", "traitr", "translate", "transport", "TreePar", "TreeSim", "TreeSimGM", "TripleR", "TSdist", "tsDyn", "TSP", "tth", "ttScreening", "TukeyC", "turboEM", "TurtleGraphics", "twostageTE", "upclass", "UScancer", "UsingR", "vardpoor", "vcd", "Vdgraph", "VennDiagram", "verification", "VideoComparison", "visreg", "vows", "vrtest", "wbs", "weatherData", "wfe", "wgaim", "WhopGenome", "WikipediR", "wordnet", "wpp2012", "wppExplorer", "wskm", "XBRL", "xergm", "XLConnect", "xlsx", "yaImpute", "yhatr", "YuGene", "yuima", "zCompositions"))
library(kernlab)
data(spam)
set.seed(3435)
trainIndicator=rbinom(4601, size=1, prob=0.5)
table(trainIndicator)
FileName <- DownloadFile(
"https://github.com/rdpeng/RepData_PeerAssessment1/blob/master/activity.zip",
"activity.zip")
con <- unz(FileName, "activity.csv")
activity_data <- read.csv(
con,
header=TRUE,
colClasses=c("numeric", "character", "numeric")
)
close(con)
DownloadFile <- function(FileUrl, FileName) {
if(!file.exists(FileName)) {
download.file(FileUrl, destfile=FileName, method="curl")
}
FileName
}
FileName <- DownloadFile(
"https://github.com/rdpeng/RepData_PeerAssessment1/blob/master/activity.zip",
"activity.zip")
con <- unz(FileName, "activity.csv")
activity_data <- read.csv(
con,
header=TRUE,
colClasses=c("numeric", "character", "numeric")
)
close(con)
DownloadFile(
"https://github.com/rdpeng/RepData_PeerAssessment1/blob/master/activity.zip",
"activity.zip")
DownloadFile(
"https://github.com/rdpeng/RepData_PeerAssessment1/blob/master/activity.zip",
"activity.zip")
FileName <- DownloadFile(
"https://github.com/rdpeng/RepData_PeerAssessment1/blob/master/activity.zip",
"activity.zip")
con <- unz(FileName, "activity.csv")
activity_data <- read.csv(
con,
header=TRUE,
colClasses=c("numeric", "character", "numeric")
)
### Coursera Data Science Specialization course ###
###   Reproducible Research - Peer Assigment 1  ###
SONEINT alias @Soc_Net_Intel
========================================================
**1. Introduction**
It is now possible to collect a large amount of data about personal movement using activity monitoring devices such as a [Fitbit](http://www.fitbit.com/fr), [Nike Fuelband](http://www.nike.com/us/en_us/c/nikeplus-fuelband), or [Jawbone Up](https://jawbone.com/up). These type of devices are part of the “quantified self” movement – a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks. But these data remain under-utilized both because the raw data are hard to obtain and there is a lack of statistical methods and software for processing and interpreting the data.
This assignment makes use of data from a personal activity monitoring device. This device collects data at 5 minute intervals through out the day. The data consists of two months of data from an anonymous individual collected during the months of October and November, 2012 and include the number of steps taken in 5 minute intervals each day.
**2. Data**
The data for this assignment can be downloaded from the course web site:
- **Dataset**: [Activity monitoring data](https://d396qusza40orc.cloudfront.net/repdata/data/activity.zip)
The variables included in this dataset are:
- **steps**: Number of steps taking in a 5-minute interval (missing values are
coded as NA)
- **date**: The date on which the measurement was taken in YYYY-MM-DD
format
- **interval**: Identifier for the 5-minute interval in which measurement was taken
The dataset is stored in a comma-separated-value (CSV) file and there are a total of 17,568 observations in this dataset.
**3. Assignment**
**3.1 Loading and preprocessing the data**
```{r read_data, echo=TRUE}
# Set the working directory on my local machine
setwd("~/Desktop/Repo/RepData_PeerAssessment1")
# Create a function to unzip & read properly the file
read_data <- function() {
activity_file = "activity.zip" # name the file
unzip_file <- unz(activity_file, "activity.csv") # unzip the file
activity_data <- read.csv(
unzip_file,
header = TRUE,
colClasses = c("numeric", "character", "numeric")
) # Read the file
activity_data$interval <- factor(activity_data$interval)
activity_data$date <- as.Date(activity_data$date, format="%Y-%m-%d")
activity_data
}
# Read the data properly
activity_data <- read_data()
```
**3.2 What is mean total number of steps taken per day?**
```{r check_data, echo=TRUE}
# Check the data
summary(activity_data) # a good overview
head(activity_data) # begining of the data
tail(activity_data) # end of the data
str(activity_data) # str function is important (ref to R programming course)
```
```{r steps_data, echo=TRUE}
# Create a function to compute the total number of steps taken per day
total_steps_per_day <- function(data) {
sum_steps_day <- aggregate(steps ~ date, data, sum)
colnames(sum_steps_day) <- c("date", "steps")
sum_steps_day
}
library(ggplot2) # we shall use ggplot2 for plotting figures
# Create a function to plot an histogram of the total number of steps per day
plot_steps <- function(steps, mean, median) {
col_names=c(paste("Mean:", mean), paste("Median:", median))
cols = c("orangered", "darkblue")
ggplot(steps, aes(x = steps)) +
geom_histogram(
colour = "darkred",
fill = "darkolivegreen1",
binwidth = 1000,
size = .5) +
geom_point(
aes(x = mean, y = 10, color = "darkgreen"),
size = 4,
shape = 4) +
geom_point(
aes(x = median, y = 10, color = "olivedrab4"),
size = 4,
shape = 4) +
geom_segment(
aes(x = mean, y = 0, xend = mean, yend = mean),
color="darkgreen",
linetype="dashed") +
geom_segment(
aes(x = median, y = 0, xend = median, yend = mean),
color="darkblue",
linetype="dashed" ) +
geom_text(data = NULL, x = (median + 1500), y = 10, label = median) +
scale_color_manual(name=element_blank(), labels=col_names, values=cols) +
labs(
title="Histogram of total number of steps taken per day",
x="Steps",
y="Frequency") +
theme(text=element_text(size = 12, family = ""),
axis.text.x = element_text(colour = "red"),
axis.text.y = element_text(colour = "blue"),
panel.background = element_rect(fill = "wheat"),
legend.position = "bottom")
}
# Compute the total number of steps per day
steps <- total_steps_per_day(activity_data)
# Compute the mean of the total number of steps per day
mean = round(mean(steps$steps), 2)
# Compute the median of the total number of steps per day
median = round(median(steps$steps), 2)
# Plot the whole values computed with the appropriate function
plot_steps(steps, mean, median)
```
**The total number of steps taken per day:**
- *`r paste("Mean:", mean)`*
- *`r paste("Median:", median)`*
**3.3 What is the average daily activity pattern?**
```{r steps_interval_pattern_data, echo=TRUE}
# Create a function to split & compute the steps per interval
steps_interval <- function(data) {
steps_splitted_by_interval <- aggregate(
data$steps,
by=list(interval=data$interval),
FUN = mean,
na.rm = TRUE
)
# Compute interval to integers for plotting in ggplot
steps_splitted_by_interval$interval <- as.integer(
levels(steps_splitted_by_interval$interval)[steps_splitted_by_interval$interval]
)
colnames(steps_splitted_by_interval) <- c("interval", "steps")
steps_splitted_by_interval
}
# Create a function to make the plot
plot_steps_interval_pattern <- function(steps_per_interval, Max_Steps_Per_Interval) {
col_names=c(paste("5-min interval with maximum steps: ", Max_Steps_Per_Interval))
cols = c("red")
ggplot(steps_per_interval, aes(x = interval, y = steps)) +
geom_line(color = "dodgerblue", size = .5) +
geom_point(
aes(x = Max_Steps_Per_Interval, y = 220, color = "red"),
size = 4,
shape = 4) +
geom_segment(
aes(x = Max_Steps_Per_Interval, y = 0, xend = Max_Steps_Per_Interval, yend = 220),
color = "orangered",
linetype = "dashed") +
geom_text(
data = NULL,
x = (Max_Steps_Per_Interval + 150),
y = 220,
label = Max_Steps_Per_Interval) +
scale_color_manual(name = element_blank(), labels = col_names, values = cols) +
labs(
title = "Average daily activity pattern of steps",
x = "Interval",
y = "Number of steps") +
theme(text=element_text(size = 12, family = ""),
axis.text.x = element_text(colour = "red"),
axis.text.y = element_text(colour = "blue"),
panel.background = element_rect(fill = "wheat"),
legend.position = "bottom")
}
# Compute the number of steps per interval
steps_per_interval <- steps_interval(activity_data)
# Compute the maximum steps per interval
Max_Steps_Per_Interval <- steps_per_interval[which.max(steps_per_interval$steps),]$interval
# Plot the results
plot_steps_interval_pattern(steps_per_interval, Max_Steps_Per_Interval)
```
The **`r Max_Steps_Per_Interval`<sup>th</sup> interval** is the maximum activity interval on the average.
**3.4 Imputing missing values**
```{r NA_data, echo=TRUE}
# Compute number of NA
NumberNAs <- nrow(activity_data)-nrow(activity_data[!complete.cases(activity_data),])
Missing_Values  <- dim(activity_data[is.na(activity_data$steps),])[1]
```
- There are **`r NumberNAs` rows** with missing values in the activity dataset.
- There are **`r Missing_Values`** missing valuez in the activity dataset.
```{r Plot_NA_data, echo=TRUE}
# Create a function to fill NA values with interval's steps means
impute_means <- function(data, defaults) {
na_indices <- which(is.na(data$steps))
defaults <- steps_per_interval
na_replacements <- unlist(
lapply(na_indices, FUN=function(idx){
interval = data[idx,]$interval
defaults[defaults$interval == interval,]$steps
}
)
)
imp_steps <- data$steps
imp_steps[na_indices] <- na_replacements
imp_steps
}
# Compute the final dataset
finalDataset <- data.frame(
steps = impute_means(activity_data, steps_per_interval),
date = activity_data$date,
interval = activity_data$interval)
summary(finalDataset)
str(finalDataset)
# Compute the complete data
Total_steps <- total_steps_per_day(finalDataset)
Total_mean = round(mean(Total_steps$steps), 2)
Total_median = round(median(Total_steps$steps), 2)
# Make the requested histogram with the previous function
plot_steps(Total_steps, Total_mean, Total_median)
```
The mean total number of steps per day is `r mean.spd1` and the *new* median is `r median.spd1`.
**Do these values differ from the estimates from the first part of the assignment?**
**3.5 Are there differences in activity patterns between weekdays and weekends?**
```{r day_of_the_week_data, echo=TRUE}
# Create a function to compute the days of the week data
Day_Of_The_Week_data_computing <- function(data) {
# Create the new factor variable for "weekday" and "weekend"
data$Days_Of_The_Week <- as.factor(weekdays(data$date))
# Note that days are in french
Week_End_Data <- subset(data, Days_Of_The_Week %in% c("Samedi","Dimanche"))
Week_Day_Data  <- subset(
data,
Days_Of_The_Week %in% c("Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi")
)
weekend_steps_interval <- steps_interval(Week_End_Data)
weekday_steps_interval <- steps_interval(Week_Day_Data)
weekend_steps_interval$weekday_or_weekend <- rep("weekend", nrow(weekend_steps_interval))
weekday_steps_interval$weekday_or_weekend <- rep("weekday", nrow(weekday_steps_interval))
Day_Of_The_Week_data <- rbind(weekend_steps_interval, weekday_steps_interval)
Day_Of_The_Week_data$weekday_or_weekend <- as.factor(Day_Of_The_Week_data$weekday_or_weekend)
Day_Of_The_Week_data
}
# Create the plot requested
plot_day_of_the_week <- function(data) {
ggplot(data,
aes(x=interval, y=steps)) +
geom_line(color="dodgerblue", size=.5) +
facet_wrap(~ weekday_or_weekend, nrow=2, ncol=1) +
labs(
title = "Average daily activity pattern of steps by weekday & weekend",
x="Interval",
y="Number of steps") +
theme(text=element_text(size = 12, family = ""),
axis.text.x = element_text(colour = "red"),
axis.text.y = element_text(colour = "blue"),
panel.background = element_rect(fill = "wheat"),
legend.position = "bottom")
}
# Compute the data
Day_Of_The_Week_data <- Day_Of_The_Week_data_computing(finalDataset)
# Make the requested plot
plot_day_of_the_week(Day_Of_The_Week_data)
```
plot_steps <- function(steps, mean, median) {
col_names=c(paste("Mean:", mean), paste("Median:", median))
cols = c("orangered", "darkblue")
ggplot(steps, aes(x = steps)) +
geom_histogram(
colour = "darkred",
fill = "darkolivegreen1",
binwidth = 1000,
size = .5) +
geom_point(
aes(x = mean, y = 10, color = "darkgreen"),
size = 4,
shape = 4) +
geom_point(
aes(x = median, y = 10, color = "olivedrab4"),
size = 4,
shape = 4) +
geom_segment(
aes(x = mean, y = 0, xend = mean, yend = mean),
color="darkgreen",
linetype="dashed") +
geom_segment(
aes(x = median, y = 0, xend = median, yend = median),
color="darkblue",
linetype="dashed" ) +
geom_text(data = NULL, x = (median + 1500), y = 10, label = median) +
scale_color_manual(name=element_blank(), labels=col_names, values=cols) +
labs(
title="Histogram of total number of steps taken per day",
x="Steps",
y="Frequency") +
theme(text=element_text(size = 12, family = ""),
axis.text.x = element_text(colour = "red"),
axis.text.y = element_text(colour = "blue"),
panel.background = element_rect(fill = "wheat"),
legend.position = "bottom")
}
# Compute the total number of steps per day
steps <- total_steps_per_day(activity_data)
# Compute the mean of the total number of steps per day
mean = round(mean(steps$steps), 2)
# Compute the median of the total number of steps per day
median = round(median(steps$steps), 2)
# Plot the whole values computed with the appropriate function
plot_steps(steps, mean, median)
plot_steps <- function(steps, mean, median) {
col_names=c(paste("Mean:", mean), paste("Median:", median))
cols = c("orangered", "darkblue")
ggplot(steps, aes(x = steps)) +
geom_histogram(
colour = "darkred",
fill = "darkolivegreen1",
binwidth = 1000,
size = .5) +
geom_point(
aes(x = mean, y = 10, color = "darkgreen"),
size = 4,
shape = 4) +
geom_point(
aes(x = median, y = 10, color = "olivedrab4"),
size = 4,
shape = 4) +
geom_segment(
aes(x = mean, y = 0, xend = mean, yend = aes(mean)),
color="darkgreen",
linetype="dashed") +
geom_segment(
aes(x = median, y = 0, xend = median, yend = aes(median)),
color="darkblue",
linetype="dashed" ) +
geom_text(data = NULL, x = (median + 1500), y = 10, label = median) +
scale_color_manual(name=element_blank(), labels=col_names, values=cols) +
labs(
title="Histogram of total number of steps taken per day",
x="Steps",
y="Frequency") +
theme(text=element_text(size = 12, family = ""),
axis.text.x = element_text(colour = "red"),
axis.text.y = element_text(colour = "blue"),
panel.background = element_rect(fill = "wheat"),
legend.position = "bottom")
}
# Compute the total number of steps per day
steps <- total_steps_per_day(activity_data)
# Compute the mean of the total number of steps per day
mean = round(mean(steps$steps), 2)
# Compute the median of the total number of steps per day
median = round(median(steps$steps), 2)
# Plot the whole values computed with the appropriate function
plot_steps(steps, mean, median)
plot_steps <- function(steps, mean, median) {
col_names=c(paste("Mean:", mean), paste("Median:", median))
cols = c("orangered", "darkblue")
ggplot(steps, aes(x = steps)) +
geom_histogram(
colour = "darkred",
fill = "darkolivegreen1",
binwidth = 1000,
size = .5) +
geom_point(
aes(x = mean, y = 10, color = "darkgreen"),
size = 4,
shape = 4) +
geom_point(
aes(x = median, y = 10, color = "olivedrab4"),
size = 4,
shape = 4) +
geom_segment(
aes(x = mean, y = 0, xend = mean, yend = aes[mean]),
color="darkgreen",
linetype="dashed") +
geom_segment(
aes(x = median, y = 0, xend = median, yend = aes[median]),
color="darkblue",
linetype="dashed" ) +
geom_text(data = NULL, x = (median + 1500), y = 10, label = median) +
scale_color_manual(name=element_blank(), labels=col_names, values=cols) +
labs(
title="Histogram of total number of steps taken per day",
x="Steps",
y="Frequency") +
theme(text=element_text(size = 12, family = ""),
axis.text.x = element_text(colour = "red"),
axis.text.y = element_text(colour = "blue"),
panel.background = element_rect(fill = "wheat"),
legend.position = "bottom")
}
# Compute the total number of steps per day
steps <- total_steps_per_day(activity_data)
# Compute the mean of the total number of steps per day
mean = round(mean(steps$steps), 2)
# Compute the median of the total number of steps per day
median = round(median(steps$steps), 2)
# Plot the whole values computed with the appropriate function
plot_steps(steps, mean, median)
